# DirectProduct

Generates the values for the specified fields and returns their direct product. 

## Implementation by builder

Describes how to define fields using DataGeneratorBuilder.

### Sample code

```c#
// Creates a context.
DataGeneratorContext context = new DataGeneratorContext();

// Creates a builder.
DataGeneratorBuilder builder = new DataGeneratorBuilder();

// Adds fields.
builder
    // A field that enumerates sequencial numbers starting with 1
    .AddField(factory => factory.SequenceInt32("ID", initialValue: 1))
    // Enumerates the direct product of three fields
    .AddTupleField(factory => DirectProductFieldFactory.CreateTupleField(
        new IDataGeneratorField[] {
            // A field that enumerates sequencial numbers from 1 to 4
            factory.SequenceInt32(
                "FIELD1",
                1,
                4
                ),
            // A field that enumerates a, b, c
            factory.Each(
                "FIELD2",
                new char?[]{ 'a', 'b', 'c' }
                ),
            // A field that enumerates true, false
            factory.Each(
                "FIELD3",
                new bool?[]{ true, false }
                ),
        },
        context
        ))
    ;

// Creates a generator that generates 30 records and returns it as a DataReader.
using IDataReader reader = await builder.BuildAsDataReaderAsync(30);
```

The IDataReader generated by this sample code will generate the following data:

The values for FIELD1, FIELD2, and FIELD3 are enumetated in 24 (= 4 * 3 * 2) cycles. 

```console
ID      FIELD1  FIELD2  FIELD3
------- ------- ------- -------
1       1       a       True
2       1       a       False
3       1       b       True
4       1       b       False
5       1       c       True
6       1       c       False
7       2       a       True
8       2       a       False
9       2       b       True
10      2       b       False
11      2       c       True
12      2       c       False
13      3       a       True
14      3       a       False
15      3       b       True
16      3       b       False
17      3       c       True
18      3       c       False
19      4       a       True
20      4       a       False
21      4       b       True
22      4       b       False
23      4       c       True
24      4       c       False
25      1       a       True
26      1       a       False
27      1       b       True
28      1       b       False
29      1       c       True
30      1       c       False
```

## Implementation by configuration

Describes how to use a configuration class to define the same fields as the sample code above.

### Sample code

```c#
// Creates a generator settings.
DataGeneratorSettings generatorSetting = new DataGeneratorSettings() { };

// Adds fields.
generatorSetting.Fields = new DataGeneratorFieldSettings[]
{
    // A field that enumerates sequencial numbers starting with 1
    new SequenceInt32FieldSettings()
    {
        FieldName = "ID",
        InitialValue = 1,
    },
};

// Adds tuple fields.
generatorSetting.TupleFields = new DataGeneratorTupleFieldSettings[]
{
    // Enumerates the direct product of three fields
    new DirectProductFieldSettings()
    {
        Fields = new DataGeneratorFieldSettings[]
        {
            // A field that enumerates sequencial numbers from 1 to 4
            new SequenceInt32FieldSettings()
            {
                FieldName = "FIELD1",
                InitialValue = 1,
                MaximumValue = 4,
            },
            // A field that enumerates a, b, c
            new EachFieldSettings<char>()
            {
                FieldName = "FIELD2",
                Values = new char?[]{ 'a', 'b', 'c' }
            },
            // A field that enumerates true, false
            new EachFieldSettings<bool>()
            {
                FieldName = "FIELD3",
                Values = new bool?[]{ true, false }
            }
        }
    }
};

// Create a context that controls the behavior of the generator.
// You can replace random number generation algorithms, string converters, etc. with your own implementation.
DataGeneratorContext context = new DataGeneratorContext();

// Creates a builder.
DataGeneratorBuilder builder = generatorSetting.CreateBuilder(context);

// Creates a generator that generates 30 records and returns it as a DataReader.
using IDataReader reader = await builder.BuildAsDataReaderAsync(30);
```


### Json serialization

The DataGeneratorSettings instance in the sample code above is serialized into a JSON string like this: 

```json
{
  "Fields": [
    {
      "Name": "ID",
      "NullProb": 0.0,
      "Initial": 1,
      "Max": null,
      "Increment": null,
      "FieldType": "SequenceInt32"
    }
  ],
  "TupleFields": [
    {
      "Fields": [
        {
          "Name": "FIELD1",
          "NullProb": 0.0,
          "Initial": 1,
          "Max": 4,
          "Increment": null,
          "FieldType": "SequenceInt32"
        },
        {
          "Name": "FIELD2",
          "NullProb": 0.0,
          "Values": [
            "a",
            "b",
            "c"
          ],
          "FieldType": "EachChar"
        },
        {
          "Name": "FIELD3",
          "NullProb": 0.0,
          "Values": [
            true,
            false
          ],
          "FieldType": "EachBoolean"
        }
      ],
      "FieldType": "DirectProduct"
    }
  ],
  "AdditionalFields": null,
  "AdditionalTupleFields": null
}
```

