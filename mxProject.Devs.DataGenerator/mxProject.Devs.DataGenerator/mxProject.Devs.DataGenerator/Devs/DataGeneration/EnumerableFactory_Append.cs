using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using System.Runtime.InteropServices.ComTypes;
using System.Runtime.InteropServices;
using System.Globalization;
using System.Data;

namespace mxProject.Devs.DataGeneration
{
    partial class EnumerableFactory
    {

        #region IDictionary<TKey, TValue>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue?)> Append<TKey, TValue>(IEnumerable<TKey> keyValue, IDictionary<TKey, TValue> additionalValues)
            where TKey : struct
            where TValue : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join);
                }
                else
                {
                    yield return (key, default);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue?)> Append<TKey, TValue>(IEnumerable<TKey> keyValue, IDictionary<TKey, TValue?> additionalValues)
            where TKey : struct
            where TValue : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join);
                }
                else
                {
                    yield return (key, default);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue?)> Append<TKey, TValue>(IEnumerable<TKey?> keyValue, IDictionary<TKey, TValue> additionalValues)
            where TKey : struct
            where TValue : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join);
                }
                else
                {
                    yield return (key, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue?)> Append<TKey, TValue>(IEnumerable<TKey?> keyValue, IDictionary<TKey, TValue?> additionalValues)
            where TKey : struct
            where TValue : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join);
                }
                else
                {
                    yield return (key, null);
                }
            }
        }

        #endregion

        #region IDictionary<TKey, (TValue1, TValue2)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?)> AppendTuple<TKey, TValue1, TValue2>(IEnumerable<TKey> keyValue, IDictionary<TKey, (TValue1, TValue2)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?)> AppendTuple<TKey, TValue1, TValue2>(IEnumerable<TKey?> keyValue, IDictionary<TKey, (TValue1, TValue2)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?)> AppendNullableTuple<TKey, TValue1, TValue2>(IEnumerable<TKey> keyValue, IDictionary<TKey, (TValue1?, TValue2?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?)> AppendNullableTuple<TKey, TValue1, TValue2>(IEnumerable<TKey?> keyValue, IDictionary<TKey, (TValue1?, TValue2?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<TKey, (TValue1, TValue2, TValue3)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey, TValue1, TValue2, TValue3>(IEnumerable<TKey> keyValue, IDictionary<TKey, (TValue1, TValue2, TValue3)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey, TValue1, TValue2, TValue3>(IEnumerable<TKey?> keyValue, IDictionary<TKey, (TValue1, TValue2, TValue3)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey, TValue1, TValue2, TValue3>(IEnumerable<TKey> keyValue, IDictionary<TKey, (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey, TValue1, TValue2, TValue3>(IEnumerable<TKey?> keyValue, IDictionary<TKey, (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4>(IEnumerable<TKey> keyValue, IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4>(IEnumerable<TKey?> keyValue, IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey, TValue1, TValue2, TValue3, TValue4>(IEnumerable<TKey> keyValue, IDictionary<TKey, (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey, TValue1, TValue2, TValue3, TValue4>(IEnumerable<TKey?> keyValue, IDictionary<TKey, (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<TKey> keyValue, IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<TKey?> keyValue, IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<TKey> keyValue, IDictionary<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<TKey?> keyValue, IDictionary<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<TKey> keyValue, IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<TKey?> keyValue, IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<TKey> keyValue, IDictionary<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<TKey?> keyValue, IDictionary<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<TKey> keyValue, IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<TKey?> keyValue, IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<TKey> keyValue, IDictionary<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<TKey?> keyValue, IDictionary<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<TKey> keyValue, IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<TKey?> keyValue, IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<TKey> keyValue, IDictionary<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<TKey?> keyValue, IDictionary<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<TKey> keyValue, IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<TKey?> keyValue, IDictionary<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<TKey> keyValue, IDictionary<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<TKey?> keyValue, IDictionary<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryGetValue(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion


        #region IDictionary<(TKey1, TKey2), TValue>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue?)> Append<TKey1, TKey2, TValue>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1, TKey2), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue?)> Append<TKey1, TKey2, TValue>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1, TKey2), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue?)> Append<TKey1, TKey2, TValue>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1?, TKey2?), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue?)> Append<TKey1, TKey2, TValue>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1?, TKey2?), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2), (TValue1, TValue2)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TValue1, TValue2>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1, TKey2), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1, TKey2), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?)> AppendNullableTuple<TKey1, TKey2, TValue1, TValue2>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1?, TKey2?), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?)> AppendNullableTuple<TKey1, TKey2, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1?, TKey2?), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey1, TKey2, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1?, TKey2?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey1, TKey2, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1?, TKey2?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1?, TKey2?), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1?, TKey2?), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1?, TKey2?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1?, TKey2?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1?, TKey2?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1?, TKey2?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1?, TKey2?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1?, TKey2?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1?, TKey2?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1?, TKey2?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1, TKey2)> keyValue, IDictionary<(TKey1?, TKey2?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1?, TKey2?)> keyValue, IDictionary<(TKey1?, TKey2?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        
        #region IDictionary<(TKey1, TKey2, TKey3), TValue>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue?)> Append<TKey1, TKey2, TKey3, TValue>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1, TKey2, TKey3), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1, TKey2, TKey3), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue?)> Append<TKey1, TKey2, TKey3, TValue>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue?)> Append<TKey1, TKey2, TKey3, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?)> AppendNullableTuple<TKey1, TKey2, TKey3, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?)> AppendNullableTuple<TKey1, TKey2, TKey3, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion


        #region IDictionary<(TKey1, TKey2, TKey3, TKey4), TValue>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion


        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), TValue>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4, TValue5)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion


        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), TValue>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4, TValue5)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion


        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), TValue>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4, TValue5)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion


        #region IDictionary<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), TValue>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1?, TValue2?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue1?, TValue2?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4, TValue5)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion


        #region IDictionary<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), TValue>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue?)> Append<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1?, TValue2?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue1?, TValue2?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue1?, TValue2?, TValue3?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4, TValue5)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #region IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)>

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.HasAllValues() && additionalValues.TryGetValue(key.ToValueOrDefault(), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TKey9">The type of the ninth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <typeparam name="TValue9">The type of the ninth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> AppendNullableTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TKey9, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8, TValue9>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?)> keyValue, IDictionary<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TKey9?), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?, TValue9?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TKey9 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
            where TValue9 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryGetValue(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8, join.Item9);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, key.Item9, null, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion













        #region Append<TKey, TValue>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue)> Append<TKey, TValue>(IEnumerable<TKey> keyValue, ILookup<TKey, TValue> additionalValues)
            where TKey : struct
            where TValue : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key, join);
                }
                else
                {
                    yield return (key, default);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue?)> Append<TKey, TValue>(IEnumerable<TKey> keyValue, ILookup<TKey, TValue?> additionalValues)
            where TKey : struct
            where TValue : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key, join);
                }
                else
                {
                    yield return (key, default);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue?)> Append<TKey, TValue>(IEnumerable<TKey?> keyValue, ILookup<TKey, TValue> additionalValues)
            where TKey : struct
            where TValue : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryFirst(key.Value, out var join))
                {
                    yield return (key, join);
                }
                else
                {
                    yield return (key, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue?)> Append<TKey, TValue>(IEnumerable<TKey?> keyValue, ILookup<TKey, TValue?> additionalValues)
            where TKey : struct
            where TValue : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryFirst(key.Value, out var join))
                {
                    yield return (key, join);
                }
                else
                {
                    yield return (key, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey, TValue1, TValue2>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?)> AppendTuple<TKey, TValue1, TValue2>(IEnumerable<TKey> keyValue, ILookup<TKey, (TValue1, TValue2)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?)> AppendTuple<TKey, TValue1, TValue2>(IEnumerable<TKey> keyValue, ILookup<TKey, (TValue1?, TValue2?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?)> AppendTuple<TKey, TValue1, TValue2>(IEnumerable<TKey?> keyValue, ILookup<TKey, (TValue1, TValue2)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryFirst(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?)> AppendTuple<TKey, TValue1, TValue2>(IEnumerable<TKey?> keyValue, ILookup<TKey, (TValue1?, TValue2?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryFirst(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey, TValue1, TValue2, TValue3>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey, TValue1, TValue2, TValue3>(IEnumerable<TKey> keyValue, ILookup<TKey, (TValue1, TValue2, TValue3)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey, TValue1, TValue2, TValue3>(IEnumerable<TKey> keyValue, ILookup<TKey, (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey, TValue1, TValue2, TValue3>(IEnumerable<TKey?> keyValue, ILookup<TKey, (TValue1, TValue2, TValue3)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryFirst(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey, TValue1, TValue2, TValue3>(IEnumerable<TKey?> keyValue, ILookup<TKey, (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryFirst(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4>(IEnumerable<TKey> keyValue, ILookup<TKey, (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4>(IEnumerable<TKey> keyValue, ILookup<TKey, (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4>(IEnumerable<TKey?> keyValue, ILookup<TKey, (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryFirst(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4>(IEnumerable<TKey?> keyValue, ILookup<TKey, (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryFirst(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key, null, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<TKey> keyValue, ILookup<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<TKey> keyValue, ILookup<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<TKey?> keyValue, ILookup<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryFirst(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<TKey?> keyValue, ILookup<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryFirst(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key, null, null, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<TKey> keyValue, ILookup<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<TKey> keyValue, ILookup<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<TKey?> keyValue, ILookup<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryFirst(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<TKey?> keyValue, ILookup<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryFirst(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<TKey> keyValue, ILookup<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<TKey> keyValue, ILookup<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<TKey?> keyValue, ILookup<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryFirst(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<TKey?> keyValue, ILookup<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryFirst(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<TKey> keyValue, ILookup<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<TKey> keyValue, ILookup<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (TKey key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<TKey?> keyValue, ILookup<TKey, (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryFirst(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey">The type of the key value.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <typeparam name="TValue8">The type of the eighth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> AppendTuple<TKey, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7, TValue8>(IEnumerable<TKey?> keyValue, ILookup<TKey, (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?, TValue8?)> additionalValues)
            where TKey : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
            where TValue8 : struct
        {
            foreach (TKey? key in keyValue)
            {
                if (key.HasValue && additionalValues.TryFirst(key.Value, out var join))
                {
                    yield return (key, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7, join.Item8);
                }
                else
                {
                    yield return (key, null, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region Append<TKey1, TKey2, TValue>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue?)> Append<TKey1, TKey2, TValue>(IEnumerable<(TKey1, TKey2)> keyValue, ILookup<(TKey1, TKey2), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue?)> Append<TKey1, TKey2, TValue>(IEnumerable<(TKey1, TKey2)> keyValue, ILookup<(TKey1, TKey2), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue?)> Append<TKey1, TKey2, TValue>(IEnumerable<(TKey1?, TKey2?)> keyValue, ILookup<(TKey1, TKey2), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue?)> Append<TKey1, TKey2, TValue>(IEnumerable<(TKey1?, TKey2?)> keyValue, ILookup<(TKey1, TKey2), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TValue1, TValue2>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TValue1, TValue2>(IEnumerable<(TKey1, TKey2)> keyValue, ILookup<(TKey1, TKey2), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TValue1, TValue2>(IEnumerable<(TKey1, TKey2)> keyValue, ILookup<(TKey1, TKey2), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?)> keyValue, ILookup<(TKey1, TKey2), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?)> keyValue, ILookup<(TKey1, TKey2), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2)> keyValue, ILookup<(TKey1, TKey2), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2)> keyValue, ILookup<(TKey1?, TKey2?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?)> keyValue, ILookup<(TKey1, TKey2), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?)> keyValue, ILookup<(TKey1?, TKey2?), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2)> keyValue, ILookup<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2)> keyValue, ILookup<(TKey1, TKey2), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?)> keyValue, ILookup<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?)> keyValue, ILookup<(TKey1, TKey2), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2)> keyValue, ILookup<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2)> keyValue, ILookup<(TKey1, TKey2), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?)> keyValue, ILookup<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?)> keyValue, ILookup<(TKey1, TKey2), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2)> keyValue, ILookup<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2)> keyValue, ILookup<(TKey1, TKey2), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?)> keyValue, ILookup<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?)> keyValue, ILookup<(TKey1, TKey2), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2)> keyValue, ILookup<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1, TKey2)> keyValue, ILookup<(TKey1, TKey2), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?)> keyValue, ILookup<(TKey1, TKey2), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <typeparam name="TValue7">The type of the seventh correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> AppendTuple<TKey1, TKey2, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6, TValue7>(IEnumerable<(TKey1?, TKey2?)> keyValue, ILookup<(TKey1, TKey2), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?, TValue7?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
            where TValue7 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6, join.Item7);
                }
                else
                {
                    yield return (key.Item1, key.Item2, null, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TValue>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TValue>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, ILookup<(TKey1, TKey2, TKey3), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TValue>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, ILookup<(TKey1, TKey2, TKey3), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, ILookup<(TKey1, TKey2, TKey3), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, ILookup<(TKey1, TKey2, TKey3), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1, TKey2, TKey3)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1, TValue2, TValue3, TValue4, TValue5, TValue6)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <typeparam name="TValue6">The type of the sixth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> AppendTuple<TKey1, TKey2, TKey3, TValue1, TValue2, TValue3, TValue4, TValue5, TValue6>(IEnumerable<(TKey1?, TKey2?, TKey3?)> keyValue, ILookup<(TKey1, TKey2, TKey3), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?, TValue6?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
            where TValue6 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5, join.Item6);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, null, null, null, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1, TKey2, TKey3, TKey4)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), (TValue1, TValue2, TValue3, TValue4, TValue5)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <typeparam name="TValue5">The type of the fifth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TValue1, TValue2, TValue3, TValue4, TValue5>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4), (TValue1?, TValue2?, TValue3?, TValue4?, TValue5?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
            where TValue5 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, join.Item1, join.Item2, join.Item3, join.Item4, join.Item5);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, null, null, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1, TValue2, TValue3, TValue4)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <typeparam name="TValue4">The type of the fourth correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TValue1?, TValue2?, TValue3?, TValue4?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TValue1, TValue2, TValue3, TValue4>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5), (TValue1?, TValue2?, TValue3?, TValue4?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
            where TValue4 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, join.Item1, join.Item2, join.Item3, join.Item4);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, null, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && key.Item6.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value, key.Item6.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && key.Item6.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value, key.Item6.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && key.Item6.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value, key.Item6.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && key.Item6.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value, key.Item6.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1, TValue2, TValue3)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && key.Item6.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value, key.Item6.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <typeparam name="TValue3">The type of the third correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TValue1?, TValue2?, TValue3?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TValue1, TValue2, TValue3>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6), (TValue1?, TValue2?, TValue3?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TValue1 : struct
            where TValue2 : struct
            where TValue3 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && key.Item6.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value, key.Item6.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, join.Item1, join.Item2, join.Item3);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, null, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && key.Item6.HasValue && key.Item7.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value, key.Item6.Value, key.Item7.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && key.Item6.HasValue && key.Item7.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value, key.Item6.Value, key.Item7.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1, TValue2)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && key.Item6.HasValue && key.Item7.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value, key.Item6.Value, key.Item7.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TValue1">The type of the first correlated value.</typeparam>
        /// <typeparam name="TValue2">The type of the second correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TValue1?, TValue2?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TValue1, TValue2>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7), (TValue1?, TValue2?)> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TValue1 : struct
            where TValue2 : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && key.Item6.HasValue && key.Item7.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value, key.Item6.Value, key.Item7.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, join.Item1, join.Item2);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, null, null);
                }
            }
        }

        #endregion

        #endregion

        #region AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>

        #region ILookup

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>(IEnumerable<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (additionalValues.TryFirst(key, out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), TValue> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && key.Item6.HasValue && key.Item7.HasValue && key.Item8.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value, key.Item6.Value, key.Item7.Value, key.Item8.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null);
                }
            }
        }

        /// <summary>
        /// Correlates the values of two collections based on matching key values.
        /// </summary>
        /// <typeparam name="TKey1">The type of the first value of the key.</typeparam>
        /// <typeparam name="TKey2">The type of the second value of the key.</typeparam>
        /// <typeparam name="TKey3">The type of the third value of the key.</typeparam>
        /// <typeparam name="TKey4">The type of the fourth value of the key.</typeparam>
        /// <typeparam name="TKey5">The type of the fifth value of the key.</typeparam>
        /// <typeparam name="TKey6">The type of the sixth value of the key.</typeparam>
        /// <typeparam name="TKey7">The type of the seventh value of the key.</typeparam>
        /// <typeparam name="TKey8">The type of the eighth value of the key.</typeparam>
        /// <typeparam name="TValue">The type of the correlated value.</typeparam>
        /// <param name="keyValue">The base collection.</param>
        /// <param name="additionalValues">The collection to join.</param>
        /// <returns></returns>
        public IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?, TValue?)> AppendTuple<TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8, TValue>(IEnumerable<(TKey1?, TKey2?, TKey3?, TKey4?, TKey5?, TKey6?, TKey7?, TKey8?)> keyValue, ILookup<(TKey1, TKey2, TKey3, TKey4, TKey5, TKey6, TKey7, TKey8), TValue?> additionalValues)
            where TKey1 : struct
            where TKey2 : struct
            where TKey3 : struct
            where TKey4 : struct
            where TKey5 : struct
            where TKey6 : struct
            where TKey7 : struct
            where TKey8 : struct
            where TValue : struct
        {
            foreach (var key in keyValue)
            {
                if (key.Item1.HasValue && key.Item2.HasValue && key.Item3.HasValue && key.Item4.HasValue && key.Item5.HasValue && key.Item6.HasValue && key.Item7.HasValue && key.Item8.HasValue && additionalValues.TryFirst((key.Item1.Value, key.Item2.Value, key.Item3.Value, key.Item4.Value, key.Item5.Value, key.Item6.Value, key.Item7.Value, key.Item8.Value), out var join))
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, join);
                }
                else
                {
                    yield return (key.Item1, key.Item2, key.Item3, key.Item4, key.Item5, key.Item6, key.Item7, key.Item8, null);
                }
            }
        }

        #endregion

        #endregion

    }
}
